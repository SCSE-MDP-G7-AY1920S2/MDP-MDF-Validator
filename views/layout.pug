doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
    link(href="https://fonts.googleapis.com/css?family=Google+Sans&display=swap" rel='stylesheet')
    script(src='https://code.jquery.com/jquery-3.4.1.slim.min.js' integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous")
    link(rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css')
    script(src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js")
    link(rel='stylesheet' href='https://fonts.googleapis.com/icon?family=Material+Icons')
  body(onload="initialize()")
    block content

    script.
      obstacleMode = false;
      selectorGrid = new Array(300).fill(0);
      submittedGrid = new Array(300).fill(-1);

      function updateMap(contents) {
        console.log(contents);
        contents = contents.replace(/(?:\r\n|\r|\n)/g, '');
        console.log(contents);
        for (var i = 0; i < contents.length; i++) {
          selectorGrid[i] = parseInt(contents.charAt(i));
        }
        drawSelectorGrid();
      }

      function openFile(func) {
        readFile = function (e) {
          var file = e.target.files[0];
          if (!file) {
            return;
          }
          var reader = new FileReader();
          reader.onload = function (e) {
            var contents = e.target.result;
            fileInput.func(contents)
            document.body.removeChild(fileInput)
          }
          reader.readAsText(file)
        }
        fileInput = document.createElement("input")
        fileInput.type = 'file'
        fileInput.style.display = 'none'
        fileInput.onchange = readFile
        fileInput.func = func
        document.body.appendChild(fileInput)
        fileInput.click();
      }

      function importMap() {
        openFile(updateMap);
      }

      async function loadSavedMaps(map) {
        console.log(map);
        M.toast({html: 'Loading Map...', displayLength: 1000});
        var filePath = `/maps/${map}.txt`;
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", filePath, true);
        xmlhttp.send();
        xmlhttp.onload = function () {
          if (xmlhttp.status == 200) {
            var result = xmlhttp.responseText;
            console.log("LOaded");
            updateMap(result);
          }
          return result;
        };
      }

      function exportMap() {
        var textToSave = selectorGrid.toString().replace(/,/g, "").replace(/(.{15})/g, "$1\n");
        var hiddenElement = document.createElement('a');
        hiddenElement.href = 'data:attachment/text,' + encodeURI(textToSave);
        hiddenElement.target = '_blank';
        hiddenElement.download = 'sampleArena.txt';
        hiddenElement.click();
      }

      function initialize() {
        console.log("Initializing");
        drawSelectorGrid();
        drawSubmittedGrid();
      }

      function setGrid(i) {
        if (!obstacleMode) return;
        console.log("Selected:", i);
        let cell = $(`#samplegrid-${i}`);
        if (cell.hasClass("mdp-free")) {
          selectorGrid[i] = 1;
          cell.removeClass("mdp-free");
          cell.addClass("mdp-obstacle");
        } else if (cell.hasClass("mdp-obstacle")) {
          selectorGrid[i] = 0;
          cell.removeClass("mdp-obstacle");
          cell.addClass("mdp-free")
        } else console.log("NO CLASS FOUND");
      }

      function drawSelectorGrid() {
        console.log("Generating Default Grid");
        let table = $("#sampleArena");
        table.html("");
        selectorGrid.forEach((element, i) => {
          switch (element) {
            case 0:
              table.append(`<div class="mdp-free" id="samplegrid-${i}" onclick="setGrid(${i})"> </div>`);
              break;
            case 1:
              table.append(`<div class="mdp-obstacle" id="samplegrid-${i}" onclick="setGrid(${i})"> </div>`);
              break;
          }
        });
      }

      function drawSubmittedGrid() {
        console.log("Generating Submission Grid");
        console.log("Submission Grid Length:", submittedGrid.length);
        let table = $("#submittedArena");
        table.html("");
        submittedGrid.forEach((element, i) => {
          switch (element) {
            case 0:
              table.append(`<div id="sg-${i}" class="mdp-free"> </div>`);
              break;
            case -1:
              table.append(`<div id="sg-${i}" class="mdp-unexplored"> </div>`);
              break;
            case 1:
              table.append(`<div id="sg-${i}" class="mdp-obstacle"> /div>`);
              break;
          }
        });
      }

      function process() {
        console.log("lol " + obstacleMode);
      }

      function toggleObstacle() {
        obstacleMode = !obstacleMode;
        if (obstacleMode) $("#prompt").removeClass("hide-elem");
        else $("#prompt").addClass("hide-elem");
      }

      var mdfHex = /[0-9A-Fa-f]+/g;

      function isHex(hex) {
        try {
          ans = BigInt("0x" + hex);
        } catch (err) {
          if (err.name == "SyntaxError") return false;
          else {
            console.log(err);
            return false;
          }
        }
        return true;
      }

      function calcScore() {
        var correct = 0; // +1 score
        var incorrect = 0; // -10 score
        var unexplored = 0; // -2 score
        submittedGrid.forEach(elem => {
          if (elem == -1) unexplored++;
        });
        for (var i = 0; i < 300; i++) {
          var s = submittedGrid[i];
          var g = selectorGrid[i];
          var o = $(`#sg-${i}`);
          if (s == -1) continue;
          if (s != g) {
            incorrect++;
            //o.html('<span class="incorrect">✗</span>');
            o.addClass("incorrect");
            o.text("✗");
          } else {
            correct++;
            //o.html('<span class="correct">✓</span>');
            o.addClass("correct");
            o.text("✓");
          }
        }
        var score = correct - (incorrect * 10) - (unexplored * 2);
        // Update
        $("#resultScore").text(score);
        $("#resultC").text(correct);
        $("#resultI").text(incorrect);
        $("#resultU").text(unexplored);
        $("#result").removeClass("hide-elem");
      }

      function validateMDF() {
        console.log("Validating...")
        var mdf1 = $("#mdf1").val();
        var mdf2 = $("#mdf2").val();
        $("#mdf1").removeClass("invalid");
        $("#mdf2").removeClass("invalid");
        console.log("MDF 1:", mdf1, " | MDF 2:", mdf2);
        if (mdf1 === '') {
          console.log("ERROR");
          $("#mdf1").addClass("invalid");
          $("#helper-mdf1").attr("data-error", "Exploration MDF String not found");
          return;
        } else if (mdf2 === '') {
          console.log("ERROR");
          $("#mdf2").addClass("invalid");
          $("#helper-mdf2").attr("data-error", "Obstacle MDF String not found");
          return;
        }
        // Check MDF Hex
        if (!isHex(mdf1)) {
          $("#mdf1").addClass("invalid");
          $("#helper-mdf1").attr("data-error", "Invalid Hexadecimal String");
          return;
        } else if (!isHex(mdf2)) {
          $("#mdf2").addClass("invalid");
          $("#helper-mdf2").attr("data-error", "Invalid Hexadecimal String");
          return;
        } else console.log("Validation Successful, Checking");
        M.toast({html: 'Validating MDF String...', displayLength: 2000});

        let xhr = new XMLHttpRequest();
        xhr.open('POST', '/submitMDF');
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        xhr.send(`mdf1=${mdf1}&mdf2=${mdf2}`);
        xhr.onload = function () {
          console.log(`Loaded: ${xhr.status} ${xhr.response}`);
          console.log(xhr.response);
          console.log(typeof (xhr.response));
          if (xhr.status == 200) {
            console.log(submittedGrid.length);
            submittedGrid = xhr.response.split(',').map(Number);
            console.log(submittedGrid.length);
            console.log(submittedGrid);
            drawSubmittedGrid();
            calcScore();
          } else {
            var gs = offlineMdfCalculation(mdf1, mdf2);
            submittedGrid = gs.split(',').map(Number);
            console.log(submittedGrid.length);
            console.log(submittedGrid);
            drawSubmittedGrid();
            calcScore();
          }
        };
        xhr.onerror = function () { // only triggers if the request couldn't be made at all
          console.log(`Network error, going offline mode`);
          var gs = offlineMdfCalculation(mdf1, mdf2);
          submittedGrid = gs.split(',').map(Number);
          console.log(submittedGrid.length);
          console.log(submittedGrid);
          drawSubmittedGrid();
          calcScore();
        };
      }

      $(document).ready(function () {
        $('.fixed-action-btn').floatingActionButton({hoverEnabled: false});
        $('.fixed-action-btn').floatingActionButton("open");
        $('.modal').modal();
      });

    script.
      function hex2bin(hex) {
        return BigInt("0x" + hex).toString(2);
      }

      function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
      }

      function reverse2DArr(arr) {
        var reversed = arr.map(function reverse(item) {
          return Array.isArray(item) && Array.isArray(item[0]) ? item.map(reverse) : item.reverse();
        });
        return reversed;
      }

      const DEBUG = false;

      function printMapDbg(arr, override = false) {
        if (!DEBUG && !override) return;
        console.log("=======================================");
        for (var i = 0; i < 15; i++) {
          s = "";
          for (var j = 0; j < 20; j++) {
            s += arr[j][i].toString();
          }
          console.log(s);
        }
        console.log("=======================================");
      }

      function offlineMdfCalculation(mdf1, mdf2) {
        console.log("Calculating MDF Offline");
        console.log("MDF1:", mdf1, ", MDF2:", mdf2);
        var m1 = hex2bin(mdf1);
        m1 = m1.substring(2, 302);
        console.log("Explored MDF:", m1);
        var exploredLen = replaceAll(m1, "0", "").length;
        var obstaclePad = exploredLen % 4;
        console.log("Explored Length:", exploredLen, "| Obstacle Padding:", obstaclePad);
        var m2s = mdf2;
        console.log("Obstacle MDF Hex Len:", m2s.length);
        var m2 = hex2bin(mdf2);
        var mdfHexToBin = m2s.length * 4;
        m2 = "0".repeat(mdfHexToBin - m2.length) + m2;
        console.log("Obstacle MDF:", m2, "| Obstacle MDF Len:", m2.length);
        console.log("Parsing Explored MDF");
        const MAPCOL = 15;
        const MAPROW = 20;
        var j = 0;
        var exploredMap = new Array(MAPROW).fill(0).map(() => new Array(MAPCOL).fill(0));
        for (var i = 0; i < MAPROW; i++) {
          for (var j = 0; j < MAPCOL; j++) {
            var conv = parseInt(m1.charAt(i * MAPCOL + j));
            exploredMap[j][i] = (conv == 0) ? -1 : 0;
          }
        }
        printMapDbg(exploredMap);
        console.log("Parsing Obstacle MDF");
        var counter = 0;
        for (var i = 0; i < MAPROW; i++) {
          for (var j = 0; j < MAPCOL; j++) {
            var str = m2.charAt(counter);
            if (exploredMap[j][i] == 0) {
              if (str == '1') {
                exploredMap[j][i] = 1;
              }
              counter++;
            }
          }
        }
        printMapDbg(exploredMap);
        // bottom up invert
        console.log("Reversing Array to send back to client")
        exploredMap = reverse2DArr(exploredMap);
        printMapDbg(exploredMap, true);

        console.log("Concatanting array into string. Len:", exploredMap.length * exploredMap[0].length);
        var send = "";
        for (var i = 0; i < MAPROW; i++) {
          for (var j = 0; j < MAPCOL; j++) {
            send += exploredMap[j][i] + ",";
          }
        }
        return send.replace(/(^,)|(,$)/g, "");
      }
